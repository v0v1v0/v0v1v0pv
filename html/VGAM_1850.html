<div class="container">

<table style="width: 100%;"><tr>
<td>vgam.control</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Control Function for vgam() </h2>

<h3>Description</h3>

<p>Algorithmic constants and parameters for running <code>vgam</code>
are set using this function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vgam.control(all.knots = FALSE, bf.epsilon = 1e-07, bf.maxit = 30,
             checkwz=TRUE, Check.rank = TRUE, Check.cm.rank = TRUE,
             criterion = names(.min.criterion.VGAM),
             epsilon = 1e-07, maxit = 30, Maxit.outer = 10,
             noWarning = FALSE,
             na.action = na.fail,
             nk = NULL, save.weights = FALSE, se.fit = TRUE,
             trace = FALSE, wzepsilon = .Machine$double.eps^0.75,
             xij = NULL, gamma.arg = 1, ...)
</code></pre>


<h3>Arguments</h3>


<table>
<tr style="vertical-align: top;">
<td><code>all.knots</code></td>
<td>

<p>logical indicating if all distinct points of
the smoothing variables are to be used as knots.
By default, <code>all.knots=TRUE</code> for
<code class="reqn">n \leq 40</code>, and
for <code class="reqn">n &gt; 40</code>,
the number of knots is approximately
<code class="reqn">40 + (n-40)^{0.25}</code>.
This increases very slowly with <code class="reqn">n</code>
so that the number of knots is approximately between 50 and 60
for large <code class="reqn">n</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bf.epsilon</code></td>
<td>

<p>tolerance used by the modified vector
backfitting algorithm for testing convergence.
Must be a positive number.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bf.maxit</code></td>
<td>

<p>maximum number of iterations allowed in
the modified vector
backfitting algorithm. Must be a positive integer.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkwz</code></td>
<td>

<p>logical indicating whether the diagonal elements of
the working weight matrices should be checked
whether they are
sufficiently positive, i.e., greater
than <code>wzepsilon</code>. If not,
any values less than <code>wzepsilon</code> are
replaced with this value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Check.rank, Check.cm.rank</code></td>
<td>

<p>See <code>vglm.control</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>

<p>character variable describing what criterion is to
be used to test for convergence.
The possibilities are listed
in <code>.min.criterion.VGAM</code>, but
most family functions only implement a few of these.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>

<p>positive convergence tolerance epsilon. Roughly
speaking, the
Newton-Raphson/Fisher-scoring/local-scoring iterations
are assumed to have
converged when two successive <code>criterion</code>
values are within
<code>epsilon</code> of each other.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>maximum number of
Newton-Raphson/Fisher-scoring/local-scoring
iterations allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Maxit.outer</code></td>
<td>

<p>maximum number of
outer iterations allowed when there are
<code>sm.os</code> or
<code>sm.ps</code> terms.
See <code>vgam</code> for a little information about
the default <em>outer iteration</em>.
Note that one can use <em>performance iteration</em>
by setting <code>Maxit.outer = 1</code>; then the
smoothing parameters will be automatically chosen at each
IRLS iteration (some specific programming
allows this).
</p>
<p>Note that <code>gam</code> uses
outer iteration by default. However, 
<code>magic</code> is only
invoked for the Gaussian family, so
the results of <code>gam</code>
may differ substantially from
<code>sm.os</code> and <code>sm.ps</code>
in general.
</p>

</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>how to handle missing values.
Unlike the SPLUS <code>gam</code> function,
<code>vgam</code> cannot handle
<code>NA</code>s when smoothing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nk</code></td>
<td>

<p>vector of length <code class="reqn">d</code> containing positive integers.
where <code class="reqn">d</code> be the number of <code>s</code> terms
in the formula.
Recycling is used if necessary.
The <code class="reqn">i</code>th value is the number of
B-spline coefficients to be
estimated for each component function of the <code class="reqn">i</code>th
<code>s()</code> term.
<code>nk</code> differs from the number of knots by some constant.
If specified, <code>nk</code> overrides the
automatic knot selection procedure.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.weights</code></td>
<td>

<p>logical indicating whether the <code>weights</code> slot
of a <code>"vglm"</code> object will be saved on the object.
If not, it will be reconstructed when needed,
e.g., <code>summary</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>

<p>logical indicating whether approximate
pointwise standard errors are to be saved on the object.
If <code>TRUE</code>, then these can be plotted
with <code>plot(..., se = TRUE)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>

<p>logical indicating if output should be produced
for each iteration.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wzepsilon</code></td>
<td>

<p>Small positive number used to test whether the diagonals
of the working weight matrices are sufficiently positive.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>noWarning</code></td>
<td>

<p>Same as <code>vglm.control</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xij</code></td>
<td>

<p>Same as <code>vglm.control</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.arg</code></td>
<td>

<p>Numeric; same as <code>gamma</code> in <code>magic</code>.
Inflation factor for optimizing the UBRE/GCV criterion.
If given, a suggested value is 1.4 to help avoid overfitting,
based on the work of Gu and co-workers
(values between 1.2 and 1.4 appeared reasonable,
based on simulations).
A warning may be given if the value is deemed out-of-range.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>other parameters that may be picked up from control
functions that are specific to the <span class="pkg">VGAM</span> family function.

</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Most of the control parameters are used within
<code>vgam.fit</code> and you will have to look at that
to understand the full details.  Many of the control
parameters are used in a similar manner by <code>vglm.fit</code>
(<code>vglm</code>) because the algorithm (IRLS) is
very similar.
</p>
<p>Setting <code>save.weights=FALSE</code> is useful for some
models because the <code>weights</code> slot of the object is
often the largest and so less memory is used to store the
object. However, for some <span class="pkg">VGAM</span> family function,
it is necessary to set <code>save.weights=TRUE</code> because
the <code>weights</code> slot cannot be reconstructed later.
</p>


<h3>Value</h3>

<p>A list with components matching the input names. A little
error checking is done, but not much.  The list is assigned
to the <code>control</code> slot of <code>vgam</code> objects.
</p>


<h3>Warning</h3>

<p>See <code>vglm.control</code>.
</p>


<h3>Note</h3>

<p><code>vgam</code> does not implement half-stepsizing,
therefore parametric models should be fitted with
<code>vglm</code>. Also, <code>vgam</code> is slower
than  <code>vglm</code> too.
</p>


<h3>Author(s)</h3>

<p> Thomas W. Yee</p>


<h3>References</h3>

<p>Yee, T. W. and Wild, C. J. (1996).
Vector generalized additive models.
<em>Journal of the Royal Statistical Society,
Series B, Methodological</em>,
<b>58</b>, 481â€“493.
</p>











<h3>See Also</h3>

<p><code>vgam</code>,
<code>vglm.control</code>,
<code>vsmooth.spline</code>,
<code>vglm</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">pneumo &lt;- transform(pneumo, let = log(exposure.time))
vgam(cbind(normal, mild, severe) ~ s(let, df = 2), multinomial,
     data = pneumo, trace = TRUE, eps = 1e-4, maxit = 10)
</code></pre>


</div>