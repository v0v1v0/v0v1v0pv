<div class="container">

<table style="width: 100%;"><tr>
<td>decorana</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Detrended Correspondence Analysis and Basic Reciprocal Averaging </h2>

<h3>Description</h3>

<p>Performs detrended correspondence analysis and basic reciprocal
averaging or orthogonal correspondence analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">decorana(veg, iweigh=0, iresc=4, ira=0, mk=26, short=0,
         before=NULL, after=NULL)

## S3 method for class 'decorana'
plot(x, choices=c(1,2), origin=TRUE,
     display=c("both","sites","species","none"),
     cex = 0.8, cols = c(1,2), type, xlim, ylim, ...)

## S3 method for class 'decorana'
text(x, display = c("sites", "species"), labels,
     choices = 1:2, origin = TRUE, select,  ...)

## S3 method for class 'decorana'
points(x, display = c("sites", "species"),
       choices=1:2, origin = TRUE, select, ...)

## deprecated: use 'scores' for scores, 'weights' for weights
## S3 method for class 'decorana'
summary(object, digits=3, origin=TRUE,
        display=c("both", "species","sites","none"), ...)

## S3 method for class 'summary.decorana'
print(x, head = NA, tail = head, ...)

downweight(veg, fraction = 5)

## S3 method for class 'decorana'
scores(x, display="sites", choices=1:4,
       origin=TRUE, tidy=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>veg</code></td>
<td>
<p>Community data, a matrix-like object. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iweigh</code></td>
<td>
<p>Downweighting of rare species (0: no). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iresc</code></td>
<td>
<p>Number of rescaling cycles (0: no rescaling). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ira</code></td>
<td>
<p>Type of analysis (0: detrended, 1: basic reciprocal averaging). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mk</code></td>
<td>
<p>Number of segments in rescaling. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>short</code></td>
<td>
<p>Shortest gradient to be rescaled. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>before</code></td>
<td>
<p>Hill's piecewise transformation: values before transformation. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>after</code></td>
<td>
<p>Hill's piecewise transformation: values after
transformation – these must correspond to values in <code>before</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, object</code></td>
<td>
<p>A <code>decorana</code> result object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choices</code></td>
<td>
<p>Axes shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin</code></td>
<td>
<p>Use true origin even in detrended correspondence analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>display</code></td>
<td>
<p>Display only sites, only species, both or neither.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex</code></td>
<td>
<p>Plot character size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>Colours used for sites and species.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of plots, partial match to <code>"text"</code>,
<code>"points"</code> or <code>"none"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>Optional text to be used instead of row names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>select</code></td>
<td>
<p>Items to be displayed.  This can either be a logical
vector which is <code>TRUE</code> for displayed items or a vector of indices
of displayed items.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim, ylim</code></td>
<td>
<p>the x and y limits (min,max) of the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits in summary output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>head, tail</code></td>
<td>
<p>Number of rows printed from the head and tail of
species and site scores. Default <code>NA</code> prints all.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fraction</code></td>
<td>
<p>Abundance fraction where downweighting begins.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tidy</code></td>
<td>
<p>Return scores that are compatible with <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a>:
all scores are in a single <code>data.frame</code>, score type is
identified by factor variable <code>score</code> (<code>"sites"</code>,
<code>"species"</code>), the names by variable <code>label</code>. These scores
are incompatible with conventional <code>plot</code> functions, but they can
be used in <span class="pkg">ggplot2</span>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments for <code>plot</code> function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In late 1970s, correspondence analysis became the method of choice for
ordination in vegetation science, since it seemed better able to cope 
with non-linear species responses than principal components
analysis. However, even correspondence analysis can produce an arc-shaped
configuration of a single gradient. Mark Hill developed detrended
correspondence analysis to correct two assumed ‘faults’ in 
correspondence analysis: curvature of straight gradients and packing
of sites at the ends of the gradient.  
</p>
<p>The curvature is removed by replacing the orthogonalization of axes
with detrending.  In orthogonalization successive axes are made
non-correlated, but detrending should remove all systematic dependence
between axes.  Detrending is performed using a smoothing window on
<code>mk</code> segments.  The packing of sites at the ends of the gradient
is undone by rescaling the axes after extraction.  After rescaling,
the axis is supposed to be scaled by ‘SD’ units, so that the
average width of Gaussian species responses is supposed to be one over
whole axis. Other innovations were the piecewise linear transformation
of species abundances and downweighting of rare species which were
regarded to have an unduly high influence on ordination axes.
</p>
<p>It seems that detrending actually works by twisting the ordination
space, so that the results look non-curved in two-dimensional
projections (‘lolly paper effect’).  As a result, the points
usually have an easily recognized triangular or diamond shaped
pattern, obviously an artefact of detrending.  Rescaling works
differently than commonly presented, too. <code>decorana</code> does not
use, or even evaluate, the widths of species responses.  Instead, it
tries to equalize the weighted standard deviation of species scores on
axis segments (parameter <code>mk</code> has no effect, since
<code>decorana</code> finds the segments internally). Function
<code>tolerance</code> returns this internal criterion and can be
used to assess the success of rescaling.
</p>
<p>The <code>plot</code> method plots species and site scores.  Classical
<code>decorana</code> scaled the axes so that smallest site score was 0 (and
smallest species score was negative), but <code>summary</code>, <code>plot</code>
and <code>scores</code> use the true origin, unless <code>origin = FALSE</code>.
</p>
<p>In addition to proper eigenvalues, the function reports
‘decorana values’ in detrended analysis. These ‘decorana
values’ are the values that the legacy code of <code>decorana</code> returns
as eigenvalues. They are estimated during iteration, and describe the
joint effects of axes and detrending. The ‘decorana values’ are
estimated before rescaling and do not show its effect on
eigenvalues. The proper eigenvalues are estimated after extraction of
the axes and they are the ratio of weighted sum of squares of site and
species scores even in detrended and rescaled solutions. These
eigenvalues are estimated for each axis separately, but they are not
additive, because higher <code>decorana</code> axes can show effects already
explained by prior axes. ‘Additive eigenvalues’ are cleansed
from the effects of prior axes, and they can be assumed to add up to
total inertia (scaled Chi-square). For proportions and cumulative
proportions explained you can use <code>eigenvals.decorana</code>.
</p>


<h3>Value</h3>

<p><code>decorana</code> returns an object of class <code>"decorana"</code>, which
has <code>print</code>, <code>summary</code>, <code>scores</code>, <code>plot</code>,
<code>points</code> and <code>text</code> methods, and support functions
<code>eigenvals</code>, <code>bstick</code>, <code>screeplot</code>,
<code>predict</code> and <code>tolerance</code>. <code>downweight</code> is an
independent function that can also be used with other methods than
<code>decorana</code>.
</p>


<h3>Note</h3>

<p><code>decorana</code> uses the central numerical engine of the
original Fortran code (which is in the public domain), or about 1/3 of
the original program.  I have tried to implement the original
behaviour, although a great part of preparatory steps were written in
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> language, and may differ somewhat from the original code. However,
well-known bugs are corrected and strict criteria used (Oksanen &amp;
Minchin 1997). 
</p>
<p>Please note that there really is no need for piecewise transformation
or even downweighting within <code>decorana</code>, since there are more
powerful and extensive alternatives in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>, but these options are
included for compliance with the original software.  If a different
fraction of abundance is needed in downweighting, function
<code>downweight</code> must be applied before <code>decorana</code>.  Function
<code>downweight</code> indeed can be applied prior to correspondence
analysis, and so it can be used together with <code>cca</code>, too.
</p>
<p>Github package <span class="pkg">natto</span> has an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> implementation of
<code>decorana</code> which allows easier inspection of the
algorithm and also easier development of the function.
</p>


<h3>Author(s)</h3>

<p>Mark O. Hill wrote the original Fortran code, the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> port was by
Jari Oksanen. </p>


<h3>References</h3>

<p>Hill, M.O. and Gauch, H.G. (1980). Detrended correspondence analysis:
an improved ordination technique. <em>Vegetatio</em> <strong>42</strong>,
47–58.
</p>
<p>Oksanen, J. and Minchin, P.R. (1997). Instability of ordination
results under changes in input data order: explanations and
remedies. <em>Journal of Vegetation Science</em> <strong>8</strong>, 447–454.
</p>


<h3>See Also</h3>

<p>For unconstrained ordination, non-metric multidimensional scaling in
<code>monoMDS</code> may be more robust (see also
<code>metaMDS</code>).  Constrained (or ‘canonical’)
correspondence analysis can be made with <code>cca</code>.
Orthogonal correspondence analysis can be made with <code>decorana</code> or
<code>cca</code>, but the scaling of results vary (and the one in
<code>decorana</code> corresponds to <code>scaling = "sites"</code> and <code>hill
  = TRUE</code> in <code>cca</code>.).  See <code>predict.decorana</code>
for adding new points to an ordination.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(varespec)
vare.dca &lt;- decorana(varespec)
vare.dca
plot(vare.dca)

### the detrending rationale:
gaussresp &lt;- function(x,u) exp(-(x-u)^2/2)
x &lt;- seq(0,6,length=15) ## The gradient
u &lt;- seq(-2,8,len=23)   ## The optima
pack &lt;- outer(x,u,gaussresp)
matplot(x, pack, type="l", main="Species packing")
opar &lt;- par(mfrow=c(2,2))
plot(scores(prcomp(pack)), asp=1, type="b", main="PCA")
plot(scores(decorana(pack, ira=1)), asp=1, type="b", main="CA")
plot(scores(decorana(pack)), asp=1, type="b", main="DCA")
plot(scores(cca(pack ~ x), dis="sites"), asp=1, type="b", main="CCA")

### Let's add some noise:
noisy &lt;- (0.5 + runif(length(pack)))*pack
par(mfrow=c(2,1))
matplot(x, pack, type="l", main="Ideal model")
matplot(x, noisy, type="l", main="Noisy model")
par(mfrow=c(2,2))
plot(scores(prcomp(noisy)), type="b", main="PCA", asp=1)
plot(scores(decorana(noisy, ira=1)), type="b", main="CA", asp=1)
plot(scores(decorana(noisy)), type="b", main="DCA", asp=1)
plot(scores(cca(noisy ~ x), dis="sites"), asp=1, type="b", main="CCA")
par(opar)
</code></pre>


</div>