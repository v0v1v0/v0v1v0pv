<div class="container">

<table style="width: 100%;"><tr>
<td>vec_proxy_equal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Equality proxy</h2>

<h3>Description</h3>

<p>Returns a proxy object (i.e. an atomic vector or data frame of atomic
vectors). For vctrs, this determines the behaviour of <code>==</code> and
<code>!=</code> (via <code>vec_equal()</code>); <code>unique()</code>, <code>duplicated()</code> (via
<code>vec_unique()</code> and <code>vec_duplicate_detect()</code>); <code>is.na()</code> and <code>anyNA()</code>
(via <code>vec_detect_missing()</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">vec_proxy_equal(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The default method calls <code>vec_proxy()</code>, as the default underlying
vector data should be equal-able in most cases. If your class is
not equal-able, provide a <code>vec_proxy_equal()</code> method that throws an
error.
</p>


<h3>Value</h3>

<p>A 1d atomic vector or a data frame.
</p>


<h3>Data frames</h3>

<p>If the proxy for <code>x</code> is a data frame, the proxy function is automatically
recursively applied on all columns as well. After applying the proxy
recursively, if there are any data frame columns present in the proxy, then
they are unpacked. Finally, if the resulting data frame only has a single
column, then it is unwrapped and a vector is returned as the proxy.
</p>


<h3>Dependencies</h3>


<ul><li> <p><code>vec_proxy()</code> called by default
</p>
</li></ul>
</div>