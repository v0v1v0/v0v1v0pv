<div class="container">

<table style="width: 100%;"><tr>
<td>misc-checkers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Miscellaneous checkers</h2>

<h3>Description</h3>

<p>These functions make check formulae of local scope based on the
correspondingly named <span class="pkg">base</span> R predicates <code>is.*</code> (e.g.,
<code>vld_data_frame</code> corresponds to the predicate
<code>is.data.frame</code>), with the following exceptions:
</p>

<ul>
<li> <p><code>vld_empty</code> is based on the predicate <code>length(.) == 0</code>
</p>
</li>
<li> <p><code>vld_formula</code> is based on the predicate
<code>typeof(.) == "language" &amp;&amp; inherits(., "formula")</code>
</p>
</li>
<li> <p><code>vld_closure</code> is based on the predicate <code>typeof(.) == "closure"</code>
</p>
</li>
<li> <p><code>vld_true</code> and <code>vld_false</code> are based on the predicates
<code>identical(., TRUE)</code> and <code>identical(., FALSE)</code>, resp.
</p>
</li>
</ul>
<p>The checkers <code>vld_true</code> and <code>vld_false</code> are all-purpose checkers to
specify <em>arbitrary</em> input validation checks.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vld_all(...)

vld_any(...)

vld_array(...)

vld_atomic(...)

vld_call(...)

vld_closure(...)

vld_data_frame(...)

vld_empty(...)

vld_environment(...)

vld_expression(...)

vld_factor(...)

vld_false(...)

vld_formula(...)

vld_function(...)

vld_language(...)

vld_list(...)

vld_matrix(...)

vld_na(...)

vld_name(...)

vld_nan(...)

vld_null(...)

vld_numeric(...)

vld_ordered(...)

vld_pairlist(...)

vld_primitive(...)

vld_recursive(...)

vld_symbol(...)

vld_table(...)

vld_true(...)

vld_unsorted(...)

vld_vector(...)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Check items, i.e., formulae that are one-sided or have a string
as left-hand side (see <em>Check Formulae of Local Scope</em> in the
documentation page firmly). These are the expressions to check.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Each function <code>vld_*</code> is a function of class
<code>"check_maker"</code>, generated by <code>localize</code>.
</p>


<h3>Value</h3>

<p>Check formula of local scope.
</p>


<h3>See Also</h3>

<p>Corresponding predicates: <code>all</code>, <code>any</code>, <code>is.array</code>, <code>is.atomic</code>, <code>is.call</code>, <code>is.data.frame</code>, <code>is.environment</code>, <code>is.expression</code>, <code>is.factor</code>, <code>is.function</code>, <code>is.language</code>, <code>is.list</code>, <code>is.matrix</code>, <code>is.na</code>, <code>is.name</code>, <code>is.nan</code>, <code>is.null</code>, <code>is.numeric</code>, <code>is.ordered</code>, <code>is.pairlist</code>, <code>is.primitive</code>, <code>is.recursive</code>, <code>is.symbol</code>, <code>is.table</code>, <code>is.unsorted</code>, <code>is.vector</code>
</p>
<p><code>globalize</code> recovers the underlying check formula of global scope.
</p>
<p>The notions of “scope” and “check item” are explained in the <em>Check Formulae</em> section of firmly.
</p>
<p>Other checkers: type-checkers, scalar-checkers
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

f &lt;- function(x, y) "Pass"

# Impose the condition that x is a formula
g &lt;- firmly(f, vld_formula(~x))
g(z ~ a + b, 0)  # [1] "Pass"
g(0, 0)          # Error: "Not formula: x"

# Impose the condition that x and y are disjoint (assuming they are vectors)
h &lt;- firmly(f, vld_empty(~intersect(x, y)))
h(letters[1:3], letters[4:5])  # [1] "Pass"
h(letters[1:3], letters[3:5])  # Error: "Not empty: intersect(x, y)"

# Use a custom error message
h &lt;- firmly(f, vld_empty("x, y must be disjoint" ~ intersect(x, y)))
h(letters[1:3], letters[3:5])  # Error: "x, y must be disjoint"

# vld_true can be used to implement any kind of input validation
ifelse_f &lt;- firmly(ifelse, vld_true(~typeof(yes) == typeof(no)))
(w &lt;- {set.seed(1); rnorm(5)})
# [1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078
ifelse_f(w &gt; 0, 0, "1")  # Error: "Not TRUE: typeof(yes) == typeof(no)"
ifelse_f(w &gt; 0, 0, 1)    # [1] 1 0 1 0 0

## End(Not run)

</code></pre>


</div>