<div class="container">

<table style="width: 100%;"><tr>
<td>vglmff-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class “vglmff” </h2>

<h3>Description</h3>

<p>  Family functions for the <span class="pkg">VGAM</span> package </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("vglmff", ...)</code>.
</p>


<h3>Slots</h3>

<p>In the following, <code class="reqn">M</code> is the number of linear/additive
predictors.
</p>

<dl>
<dt>
<code>start1</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code> to insert
code at a special position (the very start)
in <code>vglm.fit</code> or <code>vgam.fit</code>.
</p>
</dd>
<dt>
<code>blurb</code>:</dt>
<dd>
<p>Object of class <code>"character"</code> giving
a small description of the model. Important arguments such as
parameter link functions can be expressed here.
</p>
</dd>
<dt>
<code>charfun</code>:</dt>
<dd>
<p>Object of class <code>"function"</code> which
returns the characteristic function
or variance function (usually for some GLMs only).
The former uses a dummy variable x.
Both use the linear/additive predictors.
The function must have arguments
<code>function(x, eta, extra = NULL, varfun = FALSE)</code>.
The <code>eta</code> and <code>extra</code> arguments are used to obtain
the parameter values.
If <code>varfun = TRUE</code> then the function returns the
variance function, else the characteristic function (default).
Note that
one should check that the <code>infos</code> slot has a list component
called <code>charfun</code> which is <code>TRUE</code> before attempting to
use this slot.
This is an easier way to test that this slot is operable.
</p>
</dd>
<dt>
<code>constraints</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code>
which sets up any constraint matrices defined by arguments in the
family function. A <code>zero</code> argument is always fed into
<code>cm.zero.vgam</code>, whereas other constraints are fed into
<code>cm.vgam</code>.
</p>
</dd>
<dt>
<code>deviance</code>:</dt>
<dd>
<p>Object of class <code>"function"</code>
returning the deviance of the model. This slot is optional.
If present, the function must have arguments
<code>function(mu, y, w, residuals = FALSE, eta, extra = NULL)</code>.
Deviance residuals are returned if <code>residuals = TRUE</code>.
</p>
</dd>
<dt>
<code>rqresslot</code>:</dt>
<dd>
<p>Object of class <code>"function"</code>
returning the randomized quantile residuals of the distibution.
This slot is optional.
If present, the function must have arguments
<code>function(mu, y, w, eta, extra = NULL)</code>.
</p>

</dd>
<dt>
<code>fini1</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code> to insert
code at a special position in <code>vglm.fit</code> or
<code>vgam.fit</code>.
This code is evaluated immediately after the fitting.
</p>
</dd>
<dt>
<code>first</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code> to insert
code at a special position in <code>vglm</code> or
<code>vgam</code>.
</p>
</dd>
<dt>
<code>infos</code>:</dt>
<dd>
<p>Object of class <code>"function"</code> which
returns a list with components such as <code>M1</code>.
At present only a very few <span class="pkg">VGAM</span> family functions have this
feature implemented.
Those that do do not require specifying the <code>M1</code>
argument when used with <code>rcim</code>.
</p>
</dd>
<dt>
<code>initialize</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code> used
to perform error checking (especially for the variable <code>y</code>)
and obtain starting values for the model.
In general, <code>etastart</code> or
<code>mustart</code> are assigned values based on the variables <code>y</code>,
<code>x</code> and <code>w</code>.
</p>
</dd>
<dt>
<code>linkinv</code>:</dt>
<dd>
<p>Object of class <code>"function"</code> which
returns the fitted values, given the linear/additive predictors.
The function must have arguments
<code>function(eta, extra = NULL)</code>.
</p>
</dd>
<dt>
<code>last</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code> to insert code at a
special position (at the very end) of <code>vglm.fit()</code>
or <code>vgam.fit()</code>.
This code is evaluated after the fitting.
The list <code>misc</code> is often assigned components in this slot,
which becomes the <code>misc</code> slot on the fitted object.
</p>
</dd>
<dt>
<code>linkfun</code>:</dt>
<dd>
<p>Object of class <code>"function"</code> which,
given the fitted values, returns the linear/additive predictors.
If present, the function must have arguments
<code>function(mu, extra = NULL)</code>.
Most <span class="pkg">VGAM</span> family functions do not have
a <code>linkfun</code> function. They largely are for
classical exponential families, i.e., GLMs.
</p>
</dd>
<dt>
<code>loglikelihood</code>:</dt>
<dd>
<p>Object of class <code>"function"</code>
returning the log-likelihood of the model. This slot is optional.
If present, the function must have arguments
<code>function(mu, y, w, residuals = FALSE, eta, extra = NULL)</code>.
The argument <code>residuals</code> can be ignored because
log-likelihood residuals aren't defined.
</p>
</dd>
<dt>
<code>middle1</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code> to insert
code at a special position in <code>vglm.fit</code> or
<code>vgam.fit</code>.
</p>
</dd>
<dt>
<code>middle2</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code> to insert
code at a special position in <code>vglm.fit</code> or
<code>vgam.fit</code>.
</p>
</dd>
<dt>
<code>simslot</code>:</dt>
<dd>
<p>Object of class <code>"function"</code> to allow
<code>simulate</code> to work.
</p>
</dd>
<dt>
<code>hadof</code>:</dt>
<dd>
<p>Object of class <code>"function"</code>;
experimental.
</p>
</dd>
<dt>
<code>summary.dispersion</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code>
indicating whether the general VGLM formula (based on a residual
sum of squares) can be used for computing the scaling/dispersion
parameter. It is <code>TRUE</code> for most models except for nonlinear
regression models.
</p>
</dd>
<dt>
<code>vfamily</code>:</dt>
<dd>
<p>Object of class <code>"character"</code>
giving class information about the family function. Although
not developed at this stage, more flexible classes are planned
in the future. For example, family functions
<code>sratio</code>, <code>cratio</code>,
<code>cumulative</code>, and <code>acat</code>
all operate on categorical data, therefore will have a special class
called <code>"VGAMcat"</code>, say. Then if <code>fit</code> was
a <code>vglm</code> object, then <code>coef(fit)</code> would print
out the <code>vglm</code> coefficients plus <code>"VGAMcat"</code>
information as well.
</p>
</dd>
<dt>
<code>deriv</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code> which
returns a <code class="reqn">M</code>-column matrix of first derivatives of the
log-likelihood function
with respect to the linear/additive predictors, i.e., the
score vector. In Yee and Wild (1996) this is the
<code class="reqn">\bold{d}_i</code> vector. Thus each row of the
matrix returned by this slot is such a vector.
</p>
</dd>
<dt>
<code>weight</code>:</dt>
<dd>
<p>Object of class <code>"expression"</code> which
returns the second derivatives of the log-likelihood function
with respect to the linear/additive predictors.
This can be either the observed or expected information matrix, i.e.,
Newton-Raphson or Fisher-scoring respectively.
In Yee and Wild (1996) this is the
<code class="reqn">\bold{W}_i</code> matrix. Thus each row of the
matrix returned by this slot is such a matrix.
Like the <code>weights</code> slot of <code>vglm</code>/<code>vgam</code>, it is
stored in
<em>matrix-band</em> form, whereby the first <code class="reqn">M</code>
columns of the matrix are the
diagonals, followed by the upper-diagonal band, followed by the
band above that, etc. In this case, there can be up to <code class="reqn">M(M+1)</code>
columns, with the last column corresponding to the (1,<code class="reqn">M</code>) elements
of the weight matrices.
</p>
</dd>
<dt>
<code>validfitted, validparams</code>:</dt>
<dd>
<p>Functions that test that the fitted values and
all parameters are within range.
These functions can issue a warning if violations are detected.
</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt>print</dt>
<dd>
<p><code>signature(x = "vglmff")</code>:
short summary of the family function.
</p>
</dd>
</dl>
<h3>Warning </h3>

<p><span class="pkg">VGAM</span> family functions are not compatible with
<code>glm</code>, nor <code>gam()</code>
(from either <span class="pkg">gam</span> or <span class="pkg">mgcv</span>).
</p>


<h3>Note</h3>

<p>With link functions etc., one must use <code>substitute</code> to
embed the options into the code. There are two different forms:
<code>eval(substitute(expression({...}), list(...)))</code>
for expressions, and
<code>eval(substitute( function(...) { ... }, list(...) )) </code>
for functions.
</p>







<p>The <code>extra</code> argument in
<code>linkinv</code>, <code>linkfun</code>, <code>deviance</code>,
<code>loglikelihood</code>, etc.
matches with the argument <code>extra</code>
in <code>vglm</code>, <code>vgam</code> and <code>rrvglm</code>.
This allows input to be fed into all slots of a <span class="pkg">VGAM</span>
family function.
</p>
<p>The expression <code>derivative</code> is evaluated immediately
prior to <code>weight</code>, so there is provision for re-use
of variables etc.  Programmers must be careful to choose
variable names that do not interfere with <code>vglm.fit</code>,
<code>vgam.fit()</code> etc.
</p>
<p>Programmers of <span class="pkg">VGAM</span> family functions are encouraged
to keep to previous conventions regarding the naming of arguments,
e.g.,
<code>link</code> is the argument for parameter link functions,
<code>zero</code> for allowing some of the
linear/additive predictors to be an intercept term only, etc.
</p>
<p>In general, Fisher-scoring is recommended over
Newton-Raphson where tractable. Although usually slightly
slower in convergence, the weight matrices from using the
expected information are positive-definite over a larger
parameter space.
</p>


<h3>Author(s)</h3>

<p> Thomas W. Yee </p>


<h3>References</h3>

<p>Yee, T. W. and Wild, C. J. (1996).
Vector generalized additive models.
<em>Journal of the Royal Statistical Society, Series B, Methodological</em>,
<b>58</b>, 481–493.
</p>





<h3>See Also</h3>

<p><code>vglm</code>,
<code>vgam</code>,
<code>rrvglm</code>,
<code>rcim</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">cratio()
cratio(link = "clogloglink")
cratio(link = "clogloglink", reverse = TRUE)
</code></pre>


</div>